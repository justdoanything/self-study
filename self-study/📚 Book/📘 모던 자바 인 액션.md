# 모던 자바 인 액션 / 라울-게이브리얼 우르마, 마리오 푸스코, 앨런 마이크로프트 지음 / 우정은 옮김 / 한빛미디어

- Stream API
  - Stream : 한 번에 한 번씩 만들어지는 연속적인 데이터 항목들의 모임. 이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다.
  - Unix 명령어 중에서 `cat`은 두 파일을 연결해서 스트림을 생성하고 `tail -3`은 스트림의 마지막 3개 행을 제공한다. `|` 연산자로 연결되 있는 여러 명령어는 병렬적으로 동시에 수행된다.
  - 자바8에서는 `java.util.stream` 패키지에 Stream API가 추가되었고 thread 라는 복잡한 작업을 사용하지 않으면서 공짜로 병렬성을 얻을 수 있다.
- 동적 파라미터화로 Method에 Code를 전달하는 기법
  - 동적 파라미터화 : 메서드를 다른 메서드의 인수로 넘겨줄 수 있는 기능.
- Interface의 Default Method
  - 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다. 보통 다른 코드와 동시에 실행되더라도 안전하게 실행하려면 공유된 가변 데이터에x 접근하지 않아야 한다.
  - 순수 함수, 부작용 없는 함수, 상태 없는 함수
  - Collection API의 인터페이스를 구현하고 있는 수많은 Collection 프레임워크가 존재한다. 이 인터페이스에 새로운 메서드를 추가한다면 인터페이스를 구현하는 모든 클래스에 메서드를 추가해야하는 문제에 봉착한다. → 자바 8 에서는 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있다. → Default Method
  - 자바 8 이전에는 List를 구현하는 모든 클래스가 sort를 구현해야 했지만 자바 8 부터는 default sort를 구현하지 않아도 된다.
    ```java
    default void sort(Comparator<? super E> c){
      Collections.sort(this, c);
    }
    ```

- 포킹 단계 : 예를들어 리스트를 필터링할 때 한 CPU는 리스트의 앞부분을 처리하고 다른 CPU는 리스트의 뒷부분을 처리하도록 요청할 수 있다.

💡 자바8에서 멀티 코어를 극대화해서 사용할 수 있도록 다양한 기능들을 제공하게 되었다. 예전보다 병렬 처리를 보다 쉽고 명확하게 할 수 있게 되었다. 위의 3가지 포인트를 기반으로 `함수형 프로그래밍`으로 프로그램을 짤 수 있었고 그에 따라 공유된 가변 데이터에 접근하지 않도록 하는 등 신경쓰면서 코딩해야할 부분들이 많아진 것 같다. 어떻게보면 코드가 더 복잡해지고 신경써야할 부분들이 많아지겠지만 컴퓨터의 자원을 보다 더 효율적으로 쉽게 사용할 수 있을 것 같다.

- 메서드 참조 (`::`) : 이 메서드를 값으로 사용하라
  ```java
  // 기존 방식
  File[] hiddenFiles = new File(".").listFiles(new FilesFilter() {
    public boolean accept(File file) {
      return file.isHidden();
    }
  });

  // 자바8 메서드 참조를 사용한 방식
  File[] hiddenFiles = new File(".").listFiles(File::isHidden);

  posts.forEach(System.out::print);
  ```
  ```java
  // 기존 방식
  public static List<Apple> filterGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();

    for(Apple apple : inventory) {
      if(GREEN.equals(apple.getColor())){
        result.add(apple);
      }
    }
    return result;
  }
  public static List<Apple> filterHeavyApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();

    for(Apple apple : inventory) {
      if(apple.getWeight() > 150){
        result.add(apple);
      }
    }
    return result;
  }


  // 자바8 방식
  public static boolean isGreenApple(Apple apple) {
    return GREEN.equals(apple.getColor());
  }

  public static boolean isHeavyApple(Apple apple) {
    return apple.getWeight() > 150;
  }
  
  // 인수로 값을 받아서 true, false를 반환하는 함수
  public interface Predicate<T> {
    boolean test(T t);
  }

  static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
    List<Apple> result = new ArrayList<>();
    for(Apple apple : inventory) {
      if(p.test(apple)) {
        result.add(apple);
      }
    }
    return result;
  }

  filterApples(inventory, Apple::isGreenApple);
  filterApples(inventory, Apple::isHeavyApple);

  // isGreenApple, isHeavyApple 함수를 구현하는 것도 생략하고 람다로 대체할 수 있다.
  filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));
  filterApples(inventory, (Apple a) -> a.getWeight() > 150);
  ```
  ```java
  Map<Curreny, List<Transaction>> transactionByCurrencies = new HashMap<>();
  for(Transaction transaction : transactions) {
    if(transaction.getPrice() > 1000) {
      Currency currency = transaction.getCurrency();
      List<Transaction> transactionsForCurrency = transactionByCurrencies.get(currency);
      if(transactionByCurrency == null) {
        transactionByCurrency = new ArrayList<>();
        transactionByCurrencies.put(currency, transactionByCurrency);
      }
      transactionByCurrency.add(transaction);
    }
  }

  // 스트림 API 사용
  import static java.util.stream.Collectors.groupingBy;
  Map<Currency, List<Transaction>> transactionsByCurrencies =
    transactions.stream()
                    .filter((Transaction t) -> t.getPrice() > 1000)
                    .collect(Collectors.groupingBy(Transaction::getCurrency));

  List<Apple> heavyApples = inventory.stream()    // 순차처리 stream
                                          .filter((Apple a) -> a.getWeight > 150)
                                          .collect(Collectors.toList());

  List<Apple> heavyApples = inventory.parallelStream()  // 병렬처리 stream
                                          .filter((Apple a) -> a.getWeight > 150)
                                          .collect(Collectors.toList());  
  ```


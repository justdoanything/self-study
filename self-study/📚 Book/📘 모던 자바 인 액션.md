# 모던 자바 인 액션 / 라울-게이브리얼 우르마, 마리오 푸스코, 앨런 마이크로프트 지음 / 우정은 옮김 / 한빛미디어

## 개념
- Stream API
  - Stream : 한 번에 한 번씩 만들어지는 연속적인 데이터 항목들의 모임. 이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다.
  - Unix 명령어 중에서 `cat`은 두 파일을 연결해서 스트림을 생성하고 `tail -3`은 스트림의 마지막 3개 행을 제공한다. `|` 연산자로 연결되 있는 여러 명령어는 병렬적으로 동시에 수행된다.
  - 자바8에서는 `java.util.stream` 패키지에 Stream API가 추가되었고 thread 라는 복잡한 작업을 사용하지 않으면서 공짜로 병렬성을 얻을 수 있다.
- 동적 파라미터화로 Method에 Code를 전달하는 기법
  - 동적 파라미터화 : 메서드를 다른 메서드의 인수로 넘겨줄 수 있는 기능.
- Interface의 Default Method
  - 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다. 보통 다른 코드와 동시에 실행되더라도 안전하게 실행하려면 공유된 가변 데이터에x 접근하지 않아야 한다.
  - 순수 함수, 부작용 없는 함수, 상태 없는 함수
  - Collection API의 인터페이스를 구현하고 있는 수많은 Collection 프레임워크가 존재한다. 이 인터페이스에 새로운 메서드를 추가한다면 인터페이스를 구현하는 모든 클래스에 메서드를 추가해야하는 문제에 봉착한다. → 자바 8 에서는 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있다. → Default Method
  - 자바 8 이전에는 List를 구현하는 모든 클래스가 sort를 구현해야 했지만 자바 8 부터는 default sort를 구현하지 않아도 된다.
    ```java
    default void sort(Comparator<? super E> c){
      Collections.sort(this, c);
    }
    ```

- 포킹 단계 : 예를들어 리스트를 필터링할 때 한 CPU는 리스트의 앞부분을 처리하고 다른 CPU는 리스트의 뒷부분을 처리하도록 요청할 수 있다.

💡 내생각 : 자바8에서 멀티 코어를 극대화해서 사용할 수 있도록 다양한 기능들을 제공하게 되었다. 예전보다 병렬 처리를 보다 쉽고 명확하게 할 수 있게 되었다. 위의 3가지 포인트를 기반으로 `함수형 프로그래밍`으로 프로그램을 짤 수 있었고 그에 따라 공유된 가변 데이터에 접근하지 않도록 하는 등 신경쓰면서 코딩해야할 부분들이 많아진 것 같다. 어떻게보면 코드가 더 복잡해지고 신경써야할 부분들이 많아지겠지만 컴퓨터의 자원을 보다 더 효율적으로 쉽게 사용할 수 있을 것 같다.

- 함수형 인터페이스 : 추상 메서드가 오직 하나인 인터페이스

- 형식 검사 : 기대되는 람다 표현의 형식
  - Predicate<String> p = s -> list.add(s); // boolean 반환
  - Consumer<String> b = s -> list.add(s);  // boolean 반환
  - Object o = () -> { System.out.println("example")}; // 에러발생
  - Object o = (Runnable) () -> { System.out.println("example")}; // 가능

- 형식 추론 : 컴파일러는 람다 표현식의 파라미터 형식에 접근할 수 있으므로 람다 문법에서 생략할 수 있다.
  - Comparator<Apple> c = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()); // 형식 추론을 하지 않음
  - Comparator<Apple> c = (a1, a2) -> a1.getWeight().compareTo(a2.getWeight()); // 형식 추론

- 람다 캡쳐링(지역 변수 사용) : 변수는 반드시 final로 선언되어 있거나 final 처럼 값이 변경되어선 안된다.
  - 인스턴스 변수는 힙에 저장되고 지역 변수는 스택에 저장된다. 원래 변수에 접근을 허용하는 것이 아니라 자유 지역 변수`(파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수)`의 복사복을 제공한다.
  - 따라서 복사본의 값이 바뀌지 않아야 하므로 지역 변수에는 한 번만 값을 할당해야 한다는 제약이 생긴 것이다.

---

- ### 메서드 참조 (`::`) : 이 메서드를 값으로 사용하라
  ```java
  Apple::getWeight // (Apple apple) -> apple.getWeight()
  Thread.currentThread()::dumpStack  // () -> Thread.currentThread().dumpStack()
  String::substring // (str, i) -> str.substring(i)
  System.out::println // (String s) -> System.out.println(s)
  this::isValidName // (String s) -> this.isValidName(s) 
  ```

--- 

- ### Sort
  ```java
  List<JSONObject> jsonList = new ArrayList<>();
  tmpJsonList.sort((JSONObject a, JSONObject b) -> {
    return a.getInt("choice_id") - b.getInt("choice_id");
  });
  tmpJsonList.sort(Comparator.comparing((JSONObject o) -> o.getInt("choice_id")));
  tmpJsonList.sort(Comparator.comparing(Apple::getWeight));

  List<JSONObject> stringList = new ArrayList<>();
  stringList.sort((String str1, String str2) -> {
    if(str2.contains("Bad") || str2.contains("Awful"))
      return 1;
    else if(!str1.contains("Bad") && !str1.contains("Awful") && !str2.contains("Bad") && !str2.contains("Awful"))
      return 0;
    else
      return -1;
  });
  ```
  ```java
  // 코드 전달
  public class AppleComparator implements Comparator<Apple> {
    public int compare(Apple a1, Apple a2) {
      return a1.getWeight().compareTo(a2.getWeight());
    }
  }
  inventory.sort(new AppleComparator());

  // 익명 클래스 사용
  inventory.sort(new Comparator<Apple>() {
    public int compare(Apple a1, Apple a2) {
      return a1.getWeight().compareTo(a2.getWeight());
    }
  });

  // 람다 표현식 사용
  inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
  inventory.sort((a1, a2) -> a1.getWeight().compareTo(a2.getWeight()));

  // 메서드 참조 사용
  inventory.sort(comparing(Apple::getWeight));

  // 내림차순 정렬 후 같으면 국가별 정렬
  inventory.sort(comparing(Apple::getWeight)
                  .reversed()
                  .thenComparing(Apple::getCountry));
  ```

---

- ### Predicate (filter)
  ```java
  public interface ApplePredicate {
    boolean test (Apple apple);
  }

  public List<Apple> filterApples(List<Apple> inventory, ApplePredicate p) {
    List<Apple> result = new ArrayList<>();
    for(Apple apple: inventory) {
      if(p.test(apple))
        result.add(apple);
    }
    return result;
  }

  public class AppleRedAndHeavyPredicate implements ApplePredicate {
    public boolean test(Apple apple) {
      return RED.equals(apple.getColor()) && apple.getWeight() > 150;
    }
  }

  List<Apple> redAndHeavyApples = filterApples(inventory, new AppleRedAndHeavyPredicate())
  ```

  ```java
  @FunctionalInterface
  public interface Predicate<T> {
    boolean test(T t);
  }

  public <T> List<T> filter(List<T> list, Predicate<T> p){
    List<T> results = new ArrayList<>();
    for(T t: list) {
      if(p.test(t)){
        results.add(t);
      }
    }
    return results;
  }
  Predicate<String> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
  List<String> nonEmpty = filter(listOfStrings, nonEmptyStringPredicate);
  ```
  
  ```java
  public static void main(String[] args) {
    Predicate<Apple> predicateHeavyApple = (Apple a) -> a.getWeight() > 150;
    List<Apple> result = filterAppleWeight(inventory, predicateHeavyApple
                                                          .and((Apple a) -> a.getName().equals("3")));
    System.out.println("=======================");
    result.forEach(System.out::println);
  }
  
  static List<Apple> filterAppleWeight(List<Apple> list, Predicate<Apple> p){
    List<Apple> result = new ArrayList<>();
    for(Apple apple : list){
      if(p.test(apple))
        result.add(apple);
    }
    return result;
  };
  ```

  ```java
  // 기존 방식
  File[] hiddenFiles = new File(".").listFiles(new FilesFilter() {
    public boolean accept(File file) {
      return file.isHidden();
    }
  });

  // 자바8 메서드 참조를 사용한 방식
  File[] hiddenFiles = new File(".").listFiles(File::isHidden);

  posts.forEach(System.out::print);
  ```
  
  ```java
  // 기존 방식
  public static List<Apple> filterGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();

    for(Apple apple : inventory) {
      if(GREEN.equals(apple.getColor())){
        result.add(apple);
      }
    }
    return result;
  }
  public static List<Apple> filterHeavyApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();

    for(Apple apple : inventory) {
      if(apple.getWeight() > 150){
        result.add(apple);
      }
    }
    return result;
  }


  // 자바8 방식
  public static boolean isGreenApple(Apple apple) {
    return GREEN.equals(apple.getColor());
  }

  public static boolean isHeavyApple(Apple apple) {
    return apple.getWeight() > 150;
  }
  
  // 인수로 값을 받아서 true, false를 반환하는 함수
  public interface Predicate<T> {
    boolean test(T t);
  }

  static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
    List<Apple> result = new ArrayList<>();
    for(Apple apple : inventory) {
      if(p.test(apple)) {
        result.add(apple);
      }
    }
    return result;
  }

  filterApples(inventory, Apple::isGreenApple);
  filterApples(inventory, Apple::isHeavyApple);

  // isGreenApple, isHeavyApple 함수를 구현하는 것도 생략하고 람다로 대체할 수 있다.
  filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));
  filterApples(inventory, (Apple a) -> a.getWeight() > 150);
  ```
  
  ```java
  Map<Curreny, List<Transaction>> transactionByCurrencies = new HashMap<>();
  for(Transaction transaction : transactions) {
    if(transaction.getPrice() > 1000) {
      Currency currency = transaction.getCurrency();
      List<Transaction> transactionsForCurrency = transactionByCurrencies.get(currency);
      if(transactionByCurrency == null) {
        transactionByCurrency = new ArrayList<>();
        transactionByCurrencies.put(currency, transactionByCurrency);
      }
      transactionByCurrency.add(transaction);
    }
  }

  // 스트림 API 사용
  import static java.util.stream.Collectors.groupingBy;
  Map<Currency, List<Transaction>> transactionsByCurrencies =
    transactions.stream()
                    .filter((Transaction t) -> t.getPrice() > 1000)
                    .collect(Collectors.groupingBy(Transaction::getCurrency));

  List<Apple> heavyApples = inventory.stream()    // 순차처리 stream
                                          .filter((Apple a) -> a.getWeight > 150)
                                          .collect(Collectors.toList());

  List<Apple> heavyApples = inventory.parallelStream()  // 병렬처리 stream
                                          .filter((Apple a) -> a.getWeight > 150)
                                          .collect(Collectors.toList());  
  ```

---

- ### Consumer (forEach)
  ```java
  @FunctionalInterface
  public interface Consumer<T> {
    void accept(T t);
  }

  public <T> void forEach(List<T> list, Consumer<T> c){
    for(T t: list) {
      c.accept(t);
    }
  }

  forEach(
    Arrays.asList(1,2,3,4,5),
    (Integer i) -> System.out.println(i);
  )
  ```

---

- ### Function (map)
  ```java
  @FunctionalInterface
  public interface Function<T, R> {
    R apply(T t);
  }

  public <T, R> List<R> map(List<T> list, Function<T, R> f) {
    List<R> result = new ArrayList<>();
    for(T t: list) {
      result.add(f.apply(t));
    }
    return result;
  }

  List<Integer> result = map(
                              Arrays.asList("lambda", "in", "action"),
                              (String s) -> s.length()
  );
  ```
  

  () -> {}
  () -> "값"
  T : type
  E : Element
  K : Key
  V : Value
  N : Number

